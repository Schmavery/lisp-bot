(define-macro ; (lambda (x ...) ()))

(define-macro nil?
  "Takes a variadic number of arguments. Returns true if all the arguments are null. Returns true when given no arguments."
  (lambda (x ...)
    `(equal? () () ~@x)))


(define not
  (lambda (expr)
    (if expr
      false
      true)))

(define-macro and
  (lambda (x args ...)
    (if (nil? x)
      true
      `(if ~x (and ~@args) false))))

(define-macro or
  "Evaluates arguments from left to right until it hits one that evaluates to true. If none of them evaluates to true it will return false."
  (lambda (x args ...)
    (if (nil? x)
      false
      `(if ~x true (or ~@args)))))

(; this should use map instead...)
(define argsnil?
  (lambda (args)
    (or (nil? args)
        (and (nil? (car args))
             (argsnil? (cdr args))))))

(define len (lambda (coll)
  (if (nil? coll)
    0
    (+ 1 (len (cdr coll))))))

(define even-len? (lambda (coll)
  (if (nil? coll)
    true
    (not (even-len? (cdr coll))))))

(define every-other-odd
  (lambda (coll)
    (if (nil? coll)
      ()
      (if (even-len? coll)
        (every-other-odd (cdr coll))
        (cons (car coll) (every-other-odd (cdr coll)))))))

(define every-other-even
  (lambda (coll)
    (if (nil? coll)
      ()
      (if (even-len? coll)
        (cons (car coll) (every-other-even (cdr coll)))
        (every-other-even (cdr coll))))))

(define-macro let
  (lambda (vars body)
    `((lambda ~(every-other-even vars) ~body) ~@(every-other-odd vars))))

(define ->>
  (lambda (data func ...)
    (if (nil? func)
      data
      (->> ((car func) data) (cdr func)))))

(define-macro cond
  (lambda (clause ...)
  `(if ~(nil? clause)
    ()
    (if ~(car (car clause))
	  ~(car (cdr (car clause)))
	  (cond ~@(cdr clause))))))
